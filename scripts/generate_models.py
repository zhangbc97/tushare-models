import importlib.util
import inspect
import logging
import os
import sqlite3
import sys
from pathlib import Path
from typing import Any, Dict, List

from jinja2 import Environment, StrictUndefined, Template

# SQLAlchemy模型模板
MODEL_TEMPLATE = '''# This file is auto-generated by generate_models.py
# This file may be manually edited after generation
# The file has been formatted using isort and black

from typing import Any, ClassVar, Dict, List

from sqlalchemy import Column, PrimaryKeyConstraint, text

from tushare_models.core import Base, Date, DateTime, Float, Integer, String


class {{ table_name|to_camel_case }}(Base):
    """{{ table_comment }}"""

    __tablename__: str = '{{ table_name }}'
    __api_id__: ClassVar[int] = {{ api_id }}
    __api_name__: ClassVar[str] = '{{ api_name }}'
    __api_title__: ClassVar[str] = '{{ api_title }}'
    __api_info_title__: ClassVar[str] = '{{ api_info_title }}'
    __api_path__: ClassVar[List[str]] = {{ api_path }}
    __api_path_ids__: ClassVar[List[int]] = {{ api_path_ids }}
    __api_points_required__: ClassVar[int] = {{ api_points_required }}
    __api_special_permission__: ClassVar[bool] = {{ api_special_permission }}
    __has_vip__: ClassVar[bool] = {{ has_vip }}
    __dependencies__: ClassVar[List[str]] = {{ dependencies }}
    __primary_key__: ClassVar[List[str]] = {{ primary_key }}
    __start_date__: ClassVar[str | None] = {{ start_date }}
    __end_date__: ClassVar[str | None] = {{ end_date }}
    __api_params__: ClassVar[Dict[str, Any]] = {{ api_params }}
    
    __mapper_args__ = {'primary_key': __primary_key__}
    __table_args__ = (
        PrimaryKeyConstraint(*__primary_key__),
        {
            'comment': '{{ table_comment }}',
            # MySQL引擎
            'mysql_engine': 'InnoDB',
        }
    )
    {% for field in fields %}
    {{ field.name }} = Column('{{ field.original_name }}', {{ field|get_column_type }}, nullable={{ 'False' if field.original_name in primary_key else 'True' }}, comment='{{ field.comment }}')
    {%- endfor %}


# ClickHouse引擎配置
try:
    from clickhouse_sqlalchemy import engines
    setattr({{ table_name|to_camel_case }}.__table__, 'engine', engines.ReplacingMergeTree(order_by={{ table_name|to_camel_case }}.__primary_key__))
except Exception:
    pass


# StarRocks引擎配置
try:
    from tushare_models.core.dialect import TSStarRocksDDLCompiler
    {{ table_name|to_camel_case }}.__table__.dialect_options['starrocks'].update(  # type: ignore
        {
            'primary_key': ','.join({{ table_name|to_camel_case }}.__primary_key__),
            'order_by': ','.join({{ table_name|to_camel_case }}.__primary_key__),
        }
    )
except Exception:
    pass


# Databend引擎配置
try:
    from tushare_models.core.dialect import TSDatabendDDLCompiler
    {{ table_name|to_camel_case }}.__table__.dialect_options['databend'].update(  # type: ignore
        {
            'cluster_by': {{ table_name|to_camel_case }}.__primary_key__,
        }
    )
except Exception:
    pass


# Doris引擎配置
try:
    {{ table_name|to_camel_case }}.__table__.dialect_options['doris'].update(  # type: ignore
        {
            'unique_key': {{ table_name|to_camel_case }}.__primary_key__,
        }
    )
except Exception:
    pass
'''


def get_db_connection():
    """
    连接meta.db数据库

    Returns:
        sqlite3.Connection: 数据库连接对象
    """
    db_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "meta.db")
    return sqlite3.connect(db_path)


def get_api_info_from_db(api_id: int) -> Dict[str, Any] | None:
    """
    从tushare_apis表读取API基本信息

    Args:
        api_id: Tushare API ID

    Returns:
        包含API信息的字典，如果不存在则返回None
    """
    conn = get_db_connection()
    cursor = conn.cursor()

    cursor.execute(
        """
        SELECT api_id, api_group_id, name, title, description, has_vip, 
               primary_key, start_date, end_date, max_rows_per_request, 
               permission_type, min_costs, dependencies, enabled
        FROM tushare_apis
        WHERE api_id = ?
    """,
        (api_id,),
    )

    row = cursor.fetchone()
    conn.close()

    if row is None:
        return None

    return {
        "api_id": row[0],
        "api_group_id": row[1],
        "name": row[2],
        "title": row[3],
        "description": row[4],
        "has_vip": bool(row[5]),
        "primary_key": row[6],
        "start_date": row[7] if row[7] else None,
        "end_date": row[8] if row[8] else None,
        "max_rows_per_request": row[9],
        "permission_type": row[10],
        "min_costs": row[11],
        "dependencies": row[12],
        "enabled": bool(row[13]),
    }


def get_api_path_from_db(api_group_id: int) -> tuple[List[str], List[int]]:
    """
    从tushare_api_groups递归获取路径

    Args:
        api_group_id: API组ID

    Returns:
        (路径列表, 路径ID列表)的元组
    """
    conn = get_db_connection()
    cursor = conn.cursor()

    path = []
    path_ids = []
    current_id = api_group_id

    while current_id > 0:
        cursor.execute(
            """
            SELECT id, parent_id, group_name
            FROM tushare_api_groups
            WHERE id = ?
        """,
            (current_id,),
        )

        row = cursor.fetchone()
        if row is None:
            break

        path.insert(0, row[2])  # group_name
        path_ids.insert(0, row[0])  # id
        current_id = row[1]  # parent_id

    conn.close()
    return path, path_ids


def get_fields_from_db(api_name: str) -> List[Dict[str, Any]]:
    """
    从tushare_api_fields表读取字段信息

    Args:
        api_name: API名称

    Returns:
        字段信息列表（去重后的）
    """
    conn = get_db_connection()
    cursor = conn.cursor()

    cursor.execute(
        """
        SELECT field_name, field_type, comment, description, length, is_default_return
        FROM tushare_api_fields
        WHERE api_name = ?
        ORDER BY id
    """,
        (api_name,),
    )

    rows = cursor.fetchall()
    conn.close()

    fields = []
    seen_field_names = set()  # 用于去重

    for row in rows:
        field_name = row[0].lower()

        # 跳过重复的字段名
        if field_name in seen_field_names:
            continue
        seen_field_names.add(field_name)

        field_type = row[1].lower() if row[1] else "str"
        comment = row[2] if row[2] else ""
        description = row[3] if row[3] else ""
        length = row[4]

        # 优先使用description，如果为空则使用comment
        field_comment = description if description else comment

        # 处理以数字开头的字段名
        if field_name[0].isdigit():
            original_name = field_name
            name = f"_{field_name}"
        # 处理Python关键字
        elif is_python_keyword(field_name):
            original_name = field_name
            name = f"_{field_name}"
        else:
            original_name = field_name
            name = field_name

        # 特殊处理ts_code字段
        if original_name == "ts_code":
            length = 16

        # 处理日期相关字段
        if original_name.endswith("_date"):
            field_type = "date"

        # 处理data_type为空的情况
        if not field_type:
            field_type = "str"

        fields.append(
            {
                "name": name,
                "original_name": original_name,
                "data_type": field_type,
                "comment": escape_quote(field_comment),
                "length": length,
            }
        )

    return fields


def get_params_from_db(api_name: str) -> Dict[str, Any]:
    """
    从tushare_api_params表读取参数信息

    Args:
        api_name: API名称

    Returns:
        参数信息字典（去重后的）
    """
    conn = get_db_connection()
    cursor = conn.cursor()

    cursor.execute(
        """
        SELECT param_name, param_type, is_required, description
        FROM tushare_api_params
        WHERE api_name = ?
        ORDER BY id
    """,
        (api_name,),
    )

    rows = cursor.fetchall()
    conn.close()

    params = {}
    seen_param_names = set()  # 用于去重

    for row in rows:
        param_name = row[0]

        # 跳过重复的参数名
        if param_name in seen_param_names:
            continue
        seen_param_names.add(param_name)

        params[param_name] = {
            "type": row[1] if row[1] else "str",
            "required": bool(row[2]),
            "description": row[3] if row[3] else "",
        }

    return params


def escape_quote(text: str | None) -> str:
    """
    转换字符串中的引号并将中文括号替换为英文括号

    Args:
        text: 需要处理的字符串

    Returns:
        处理后的字符串
    """
    if text is None:
        return ""
    # 先替换括号，再处理引号
    text = text.replace("（", "(").replace("）", ")")  # 替换中文括号为英文括号
    return text.replace("'", "\\'").replace('"', '\\"')


def is_python_keyword(name: str) -> bool:
    """
    检查是否是Python关键字

    Args:
        name: 需要检查的名称

    Returns:
        是否是Python关键字
    """
    import keyword

    return keyword.iskeyword(name)


def to_camel_case(snake_str: str) -> str:
    """
    将下划线形式转换为驼峰命名

    Args:
        snake_str: 下划线形式的字符串

    Returns:
        驼峰命名形式的字符串
    """
    components = snake_str.split("_")
    return "".join(x.title() for x in components)


def get_column_type(field: Dict[str, Any]) -> str:
    """
    根据字段类型返回对应的SQLAlchemy列类型

    Args:
        field: 字段信息字典

    Returns:
        SQLAlchemy列类型字符串

    Raises:
        ValueError: 当字段类型未知时
    """
    data_type = field["data_type"].lower() if field["data_type"] else "str"

    match data_type:
        case "str" | "varchar" | "string":
            # 只有ts_code字段才指定具体长度，其他用空括号
            return f"String({field['length']})" if field.get("length") else "String()"
        case "float" | "number" | "double" | "float64":
            return "Float"
        case "int" | "bigint" | "integer" | "int64":
            return "Integer"
        case "datetime" | "timestamp":
            return "DateTime"
        case "date":
            return "Date"
        case "json":
            return "String()"  # JSON类型使用空括号
        case _:
            raise ValueError(f"Unsupported data_type: {data_type} for field {field['name']}")


def generate_model(api_id: int, output_dir: str):
    """
    生成SQLAlchemy模型文件

    Args:
        api_id: Tushare API ID
        output_dir: 输出目录
    """
    logging.info(f"开始处理 API ID: {api_id}")

    # 从数据库获取API信息
    api_info = get_api_info_from_db(api_id)
    if api_info is None:
        logging.warning(f"API {api_id} 不存在，跳过")
        return

    if not api_info["enabled"]:
        logging.warning(f"API {api_id} ({api_info['name']}) 未启用，跳过")
        return

    api_name = api_info["name"]
    output_path = os.path.join(output_dir, f"{api_name}.py")

    # 获取API路径信息
    api_path, api_path_ids = get_api_path_from_db(api_info["api_group_id"])

    # 获取字段列表
    fields = get_fields_from_db(api_name)
    if not fields:
        logging.warning(f"API {api_id} ({api_name}) 没有字段信息，跳过")
        return

    # 获取参数信息
    api_params = get_params_from_db(api_name)

    # 处理主键
    primary_key = (
        [k.strip() for k in api_info["primary_key"].split(",") if k.strip()] if api_info["primary_key"] else []
    )

    # 处理依赖
    dependencies = (
        [d.strip() for d in api_info["dependencies"].split(",") if d.strip()] if api_info["dependencies"] else []
    )

    # 判断是否需要特殊权限（基于permission_type）
    special_permission = api_info["permission_type"] not in ("", "normal", "free")

    # 准备模板变量
    template_vars = {
        "table_name": api_name,
        "fields": fields,
        "table_comment": escape_quote(api_info["title"]),
        "api_id": api_info["api_id"],
        "api_name": api_name,
        "api_title": escape_quote(api_info["title"]),
        "api_info_title": escape_quote(api_info["title"]),
        "api_path": api_path if api_path else [api_info["title"]],
        "api_path_ids": api_path_ids if api_path_ids else [],
        "api_points_required": api_info["min_costs"],
        "api_special_permission": special_permission,
        "has_vip": api_info["has_vip"],
        "primary_key": primary_key,
        "dependencies": dependencies,
        "start_date": repr(api_info["start_date"]) if api_info["start_date"] else None,
        "end_date": repr(api_info["end_date"]) if api_info["end_date"] else None,
        "api_params": api_params,
    }

    # 创建Jinja2环境并添加过滤器
    env = Template.environment_class(undefined=StrictUndefined)
    env.filters["to_camel_case"] = to_camel_case
    env.filters["get_column_type"] = get_column_type

    # 使用环境创建模板
    template = env.from_string(MODEL_TEMPLATE)
    output = template.render(**template_vars)

    # 确保输出目录存在
    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    # 写入文件
    with open(output_path, "w", encoding="utf-8") as f:
        f.write(output)

    logging.info(f"成功生成模型文件: {output_path}")


def get_classes_from_module(module_name: str, module_path: Path, package_name: str) -> List[str]:
    """获取模块中所有的类"""
    try:
        # 临时添加项目根目录到 sys.path
        project_root = str(Path(__file__).parent.parent / "src")
        if project_root not in sys.path:
            sys.path.insert(0, project_root)

        # 使用完整的模块名（包含包名）
        full_module_name = f"{package_name}.{module_name}"

        # 使用 importlib 导入模块
        spec = importlib.util.spec_from_file_location(full_module_name, str(module_path))
        if spec is None or spec.loader is None:
            return []

        module = importlib.util.module_from_spec(spec)
        sys.modules[full_module_name] = module  # 添加到 sys.modules 以支持循环导入
        spec.loader.exec_module(module)

        classes = []
        for name, obj in inspect.getmembers(module):
            # 只获取定义在当前模块中的类（排除导入的类）
            if inspect.isclass(obj) and obj.__module__ == full_module_name and not name.startswith("_"):
                classes.append(name)

        # 清理 sys.path
        if project_root in sys.path:
            sys.path.remove(project_root)

        return classes

    except Exception as e:
        logging.warning(f"无法处理模块 {module_path.name}: {str(e)}")
        return []


def regenerate_init_file(models_dir: str):
    """重新生成 __init__.py 文件"""
    logging.info("开始重新生成 __init__.py 文件")

    models_path = Path(models_dir)
    if not models_path.exists():
        logging.error(f"模型目录不存在: {models_dir}")
        return

    # 获取包名（从路径中提取）
    package_name = models_path.name  # 'tushare_models'

    # 获取所有.py文件
    py_files = []
    for file in sorted(os.listdir(models_path)):
        if file.endswith(".py") and file != "__init__.py":
            module_name = file[:-3]  # 移除.py后缀
            module_path = models_path / file
            classes = get_classes_from_module(module_name, module_path, package_name)
            if classes:  # 只添加包含类的模块
                py_files.append((module_name, classes))

    # 创建模板
    template_str = """# This file is auto-generated. Do not edit it manually.

{% for module, classes in modules %}
from .{{ module }} import {{ classes|join(', ') }}
{% endfor %}

__all__ = [
{% for module, classes in modules %}
{% for class_name in classes %}
    "{{ class_name }}",
{% endfor %}
{% endfor %}
]
"""

    env = Environment(trim_blocks=True, lstrip_blocks=True)
    template = env.from_string(template_str)

    # 渲染模板
    output = template.render(modules=py_files)

    # 写入文件
    init_path = models_path / "__init__.py"
    with open(init_path, "w", encoding="utf-8") as f:
        f.write(output)

    logging.info(f"成功生成 __init__.py，包含 {len(py_files)} 个模块")


if __name__ == "__main__":
    # 配置日志格式
    logging.basicConfig(
        level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s", datefmt="%Y-%m-%d %H:%M:%S"
    )

    output_dir = "src/tushare_models"

    # 从数据库获取所有启用的API
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT api_id, name FROM tushare_apis WHERE enabled = 1 ORDER BY api_id")
    api_data = cursor.fetchall()
    conn.close()

    api_ids = [row[0] for row in api_data]
    generated_files = set(f"{row[1]}.py" for row in api_data)

    logging.info(f"找到 {len(api_ids)} 个启用的API")

    # 生成所有模型
    for api_id in api_ids:
        try:
            generate_model(api_id=api_id, output_dir=output_dir)
        except Exception as e:
            logging.error(f"生成 API {api_id} 的模型时出错: {str(e)}")
            import traceback

            traceback.print_exc()

    # 删除不再需要的模型文件
    if os.path.exists(output_dir):
        existing_files = [f for f in os.listdir(output_dir) if f.endswith(".py") and f != "__init__.py"]
        files_to_delete = set(existing_files) - generated_files

        if files_to_delete:
            logging.info(f"发现 {len(files_to_delete)} 个需要删除的旧模型文件")
            for file_name in sorted(files_to_delete):
                file_path = os.path.join(output_dir, file_name)
                try:
                    os.remove(file_path)
                    logging.info(f"已删除文件: {file_path}")
                except Exception as e:
                    logging.error(f"删除文件 {file_path} 时出错: {str(e)}")
        else:
            logging.info("没有需要删除的旧模型文件")

    # 重新生成 __init__.py 文件
    regenerate_init_file(output_dir)

    logging.info("所有模型生成完成")
